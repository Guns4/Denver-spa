-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- 0. DEFINE ENUMS (Strict Typing at DB Level)
create type processing_status as enum ('pending', 'confirmed', 'completed', 'cancelled');
create type payment_state as enum ('unpaid', 'paid', 'refunded');
create type shift_status as enum ('active', 'break', 'off_duty');

-- 1. THERAPISTS TABLE
create table public.therapists (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  specialty text not null,
  is_active boolean default true,
  current_shift_status shift_status default 'off_duty',
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. SERVICES TABLE
create table public.services (
  id bigint generated by default as identity primary key,
  name text not null,
  price numeric not null,
  duration_minutes integer not null,
  description text,
  image_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 3. BOOKINGS TABLE
create table public.bookings (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid references auth.users(id) on delete cascade not null, -- Links to Supabase Auth
  service_id bigint references public.services(id) on delete restrict not null, -- Prevent deleting service if booked
  therapist_id uuid references public.therapists(id) on delete set null, -- Keep booking if therapist deleted
  start_time timestamp with time zone not null,
  end_time timestamp with time zone not null,
  status processing_status default 'pending',
  payment_status payment_state default 'unpaid',
  customer_name text not null,
  customer_phone text not null,
  notes text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- CONSTRAINT: End time must be after start time
  constraint check_booking_dates check (end_time > start_time)
);

-- 4. AUTOMATIC TIMESTAMP TRIGGER
create or replace function update_updated_at_column()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language 'plpgsql';

-- 5. PREVENT PAST BOOKINGS TRIGGER (AUDIT REQUIREMENT)
create or replace function check_future_booking()
returns trigger as $$
begin
    -- Only check on INSERT to allow historical data updates if necessary by Admin
    if (TG_OP = 'INSERT') then
        if (new.start_time < now()) then
             raise exception 'Booking cannot be in the past';
        end if;
    end if;
    return new;
end;
$$ language 'plpgsql';

create trigger update_therapists_modtime before update on public.therapists for each row execute procedure update_updated_at_column();
create trigger update_services_modtime before update on public.services for each row execute procedure update_updated_at_column();
create trigger update_bookings_modtime before update on public.bookings for each row execute procedure update_updated_at_column();

-- Enforce Future Booking Check on INSERT
create trigger enforce_future_booking before insert on public.bookings for each row execute procedure check_future_booking();

-- ROW LEVEL SECURITY (RLS) POLICIES
-- Enable RLS on all tables
alter table public.therapists enable row level security;
alter table public.services enable row level security;
alter table public.bookings enable row level security;

-- POLICIES FOR SERVICES (Public Read, Admin Write)
create policy "Services are public" on public.services for select using (true);
create policy "Admins can manage services" on public.services for all using (auth.uid() in (select id from auth.users where email = 'admin@denver-inn.com'));

-- POLICIES FOR THERAPISTS (Public Read, Admin Write)
create policy "Therapists are public" on public.therapists for select using (true);
create policy "Admins can manage therapists" on public.therapists for all using (auth.uid() in (select id from auth.users where email = 'admin@denver-inn.com'));

-- POLICIES FOR BOOKINGS (Private: User sees own, Admin sees all)
create policy "Users can view own bookings" on public.bookings for select using (auth.uid() = user_id);
create policy "Users can insert own bookings" on public.bookings for insert with check (auth.uid() = user_id);
create policy "Admins can view all bookings" on public.bookings for select using (auth.uid() in (select id from auth.users where email = 'admin@denver-inn.com'));
create policy "Admins can update booking status" on public.bookings for update using (auth.uid() in (select id from auth.users where email = 'admin@denver-inn.com'));

-- REALTIME SUBSCRIPTION setup
-- Enable realtime for bookings to support "Live Slots"
alter publication supabase_realtime add table public.bookings;
alter publication supabase_realtime add table public.therapists;

-- ==========================================
-- PHASE 36: HOUSEKEEPING PROTOCOL (ROOMS)
-- ==========================================

-- 0. Define Room Status
create type room_status as enum ('ready', 'occupied', 'dirty', 'cleaning');

-- 1. Create Rooms Table
create table public.rooms (
  id bigint generated by default as identity primary key,
  name text not null, -- "Suite 1", "Room 2"
  status room_status default 'ready',
  last_cleaned_at timestamp with time zone default now(),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. Housekeeping Policies
alter table public.rooms enable row level security;
create policy "Staff can view rooms" on public.rooms for select using (true);
create policy "Staff can update rooms" on public.rooms for update using (auth.uid() in (select id from auth.users where email = 'admin@denver-inn.com'));

-- 3. Room Status Transition Logic (Simplified)
-- In a real app, this would check bookings to auto-set 'occupied'.
-- For now, we will rely on manual updates or API calls.

create trigger update_rooms_modtime before update on public.rooms for each row execute procedure update_updated_at_column();
alter publication supabase_realtime add table public.rooms;


-- ==========================================
-- PHASE 38: YIELD MANAGEMENT (HAPPY HOUR)
-- ==========================================

-- 1. Create Promotions Table
create table public.promotions (
  id bigint generated by default as identity primary key,
  name text not null, -- "Weekday Morning"
  code text unique not null,
  discount_percentage integer not null check (discount_percentage > 0 and discount_percentage <= 100),
  
  -- Time Rules
  valid_days integer[] not null, -- Array of days (0=Sun, 1=Mon, etc)
  start_hour integer not null check (start_hour >= 0 and start_hour <= 23),
  end_hour integer not null check (end_hour >= 0 and end_hour <= 23),
  
  is_active boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. Promotion Policies
alter table public.promotions enable row level security;
create policy "Public can view promotions" on public.promotions for select using (true);

-- 3. Seed Default "Happy Hour"
insert into public.promotions (name, code, discount_percentage, valid_days, start_hour, end_hour)
values ('Weekday Morning Bliss', 'HAPPYHOUR', 20, ARRAY[1,2,3,4], 10, 14);


-- ==========================================
-- PHASE 41: VIRAL REFERRAL SYSTEM
-- ==========================================

-- 1. Create Profiles Table (User Extended Info)
create table public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  full_name text,
  phone text,
  referral_code text unique not null, -- e.g., "BUDI-88"
  referred_by uuid references public.profiles(id) on delete set null, -- Who invited this user
  loyalty_points integer default 0,
  total_bookings integer default 0,
  last_visit timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. Trigger for profiles updated_at
create trigger update_profiles_modtime before update on public.profiles for each row execute procedure update_updated_at_column();

-- 3. Function to Generate Unique Referral Code
create or replace function generate_referral_code()
returns text as $$
declare
  new_code text;
  code_exists boolean;
begin
  loop
    -- Generate code like "USER-12" (first 4 chars of UUID + random 2-digit number)
    new_code := upper(substring(md5(random()::text) from 1 for 4)) || '-' || lpad((random() * 99)::int::text, 2, '0');
    
    -- Check if code already exists
    select exists(select 1 from public.profiles where referral_code = new_code) into code_exists;
    
    -- Exit loop if code is unique
    exit when not code_exists;
  end loop;
  
  return new_code;
end;
$$ language plpgsql;

-- 4. Trigger to Auto-Generate Referral Code on Profile Creation
create or replace function set_referral_code()
returns trigger as $$
begin
  if new.referral_code is null then
    new.referral_code := generate_referral_code();
  end if;
  return new;
end;
$$ language plpgsql;

create trigger set_referral_code_trigger
  before insert on public.profiles
  for each row
  execute function set_referral_code();

-- 5. RLS Policies for Profiles
alter table public.profiles enable row level security;

create policy "Users can view own profile"
  on public.profiles for select
  using (auth.uid() = id);

create policy "Users can update own profile"
  on public.profiles for update
  using (auth.uid() = id);

create policy "Users can insert own profile"
  on public.profiles for insert
  with check (auth.uid() = id);

-- 6. Function to Award Referral Bonus (Trigger on first completed booking)
create or replace function award_referral_bonus()
returns trigger as $$
declare
  referrer_id uuid;
  first_booking boolean;
begin
  -- Only trigger when booking is marked as 'completed'
  if new.status = 'completed' and (old.status is null or old.status != 'completed') then
    
    -- Check if this is user's first completed booking
    select count(*) = 1 into first_booking
    from public.bookings
    where user_id = new.user_id and status = 'completed';
    
    if first_booking then
      -- Get the referrer (who invited this user)
      select referred_by into referrer_id
      from public.profiles
      where id = new.user_id;
      
      if referrer_id is not null then
        -- Award 50 points to the referrer
        update public.profiles
        set loyalty_points = loyalty_points + 50
        where id = referrer_id;
      end if;
    end if;
  end if;
  
  return new;
end;
$$ language plpgsql;

create trigger award_referral_on_completion
  after insert or update on public.bookings
  for each row
  execute function award_referral_bonus();


-- ==========================================
-- PHASE 41b: GAMIFIED TIER SYSTEM
-- ==========================================

-- 1. Define User Tiers
create type user_tier as enum ('bronze', 'silver', 'gold');

-- 2. Add Tier Column to Profiles
alter table public.profiles add column tier user_tier default 'bronze';
alter table public.profiles add column tier_benefits jsonb default '{"discount": 0, "priority_booking": false}'::jsonb;
alter table public.profiles add column total_successful_referrals integer default 0;

-- 3. Create Referrals Tracking Table (for detailed history)
create table public.referrals (
  id uuid primary key default uuid_generate_v4(),
  referrer_id uuid not null references public.profiles(id) on delete cascade,
  referred_user_id uuid not null references public.profiles(id) on delete cascade,
  referral_status text default 'pending', -- 'pending', 'completed', 'inactive'
  first_booking_completed boolean default false,
  reward_claimed boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  unique(referrer_id, referred_user_id) -- Prevent duplicate referrals
);

-- 4. RLS for Referrals
alter table public.referrals enable row level security;
create policy "Users can view own referrals"
  on public.referrals for select
  using (auth.uid() = referrer_id);

-- 5. Function to Calculate Tier Based on Successful Referrals
create or replace function calculate_user_tier(successful_referrals integer)
returns user_tier as $$
begin
  if successful_referrals >= 10 then
    return 'gold';
  elsif successful_referrals >= 3 then
    return 'silver';
  else
    return 'bronze';
  end if;
end;
$$ language plpgsql immutable;

-- 6. Function to Get Tier Benefits
create or replace function get_tier_benefits(tier_level user_tier)
returns jsonb as $$
begin
  case tier_level
    when 'gold' then
      return '{"discount": 10, "priority_booking": true, "free_drink": true, "name": "Gold Elite"}'::jsonb;
    when 'silver' then
      return '{"discount": 5, "priority_booking": false, "free_drink": false, "name": "Silver VIP"}'::jsonb;
    else
      return '{"discount": 0, "priority_booking": false, "free_drink": false, "name": "Bronze Member"}'::jsonb;
  end case;
end;
$$ language plpgsql immutable;

-- 7. Trigger to Auto-Upgrade Tier When Referral Completes First Booking
create or replace function update_referrer_tier()
returns trigger as $$
declare
  referrer_record record;
  new_tier user_tier;
  new_benefits jsonb;
begin
  -- When a referred user completes their first booking
  if new.status = 'completed' and (old.status is null or old.status != 'completed') then
    
    -- Find if this user was referred by someone
    select * into referrer_record
    from public.profiles
    where id = (select referred_by from public.profiles where id = new.user_id);
    
    if referrer_record.id is not null then
      -- Mark referral as completed
      update public.referrals
      set first_booking_completed = true, referral_status = 'completed'
      where referred_user_id = new.user_id and referrer_id = referrer_record.id;
      
      -- Increment successful referrals count
      update public.profiles
      set total_successful_referrals = total_successful_referrals + 1
      where id = referrer_record.id;
      
      -- Calculate new tier
      new_tier := calculate_user_tier(referrer_record.total_successful_referrals + 1);
      new_benefits := get_tier_benefits(new_tier);
      
      -- Update tier and benefits
      update public.profiles
      set tier = new_tier, tier_benefits = new_benefits
      where id = referrer_record.id;
    end if;
  end if;
  
  return new;
end;
$$ language plpgsql;

create trigger update_tier_on_referral_completion
  after insert or update on public.bookings
  for each row
  execute function update_referrer_tier();


-- ==========================================
-- PHASE 57: INCIDENT LOG & BLACKLIST PROTOCOL
-- ==========================================

-- 1. Incident Categories Enum
create type incident_category as enum (
  'no_show',
  'inappropriate_behavior',
  'refused_payment',
  'drunk_disorderly',
  'other'
);

-- 2. Incident Reports Table
create table public.incident_reports (
  id uuid primary key default uuid_generate_v4(),
  guest_phone text not null, -- Primary identifier for guests
  guest_name text,
  booking_id uuid references public.bookings(id) on delete set null,
  category incident_category not null,
  severity integer check (severity between 1 and 5), -- 1=Minor, 5=Severe
  description text not null,
  reported_by uuid references auth.users(id) on delete set null, -- Staff member who reported
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  resolved boolean default false,
  resolution_notes text,
  resolved_at timestamp with time zone
);

-- 3. Guest Blacklist Table
create table public.guest_blacklist (
  id uuid primary key default uuid_generate_v4(),
  phone text unique not null, -- Primary identifier
  name text,
  reason text not null,
  incident_count integer default 1,
  blacklisted_at timestamp with time zone default timezone('utc'::text, now()) not null,
  blacklisted_by uuid references auth.users(id) on delete set null,
  is_permanent boolean default false, -- Permanent vs temporary ban
  expires_at timestamp with time zone, -- NULL if permanent
  notes text
);

-- 4. RLS Policies (Admin Only)
alter table public.incident_reports enable row level security;
alter table public.guest_blacklist enable row level security;

-- Only admins can view/create incident reports
create policy "Admins can manage incident reports"
  on public.incident_reports for all
  using (
    exists (
      select 1 from auth.users
      where auth.uid() = id
      -- Add your admin check logic here (e.g., check user_metadata ->> 'role' = 'admin')
    )
  );

create policy "Admins can manage blacklist"
  on public.guest_blacklist for all
  using (
    exists (
      select 1 from auth.users
      where auth.uid() = id
      -- Add your admin check logic here
    )
  );

-- 5. Function to Auto-Blacklist After Multiple Incidents
create or replace function auto_blacklist_check()
returns trigger as $$
declare
  incident_count_for_guest integer;
  guest_phone_number text;
begin
  -- Get phone from the incident report
  guest_phone_number := new.guest_phone;
  
  -- Count total severe incidents for this guest
  select count(*) into incident_count_for_guest
  from public.incident_reports
  where guest_phone = guest_phone_number
    and severity >= 4; -- Only severe incidents
  
  -- If 2+ severe incidents, auto-blacklist
  if incident_count_for_guest >= 2 then
    insert into public.guest_blacklist (phone, name, reason, incident_count, is_permanent)
    values (
      guest_phone_number,
      new.guest_name,
      'Auto-blacklisted: Multiple severe incidents',
      incident_count_for_guest,
      true
    )
    on conflict (phone) do update
    set incident_count = incident_count_for_guest,
        is_permanent = true;
  end if;
  
  return new;
end;
$$ language plpgsql;

create trigger check_auto_blacklist
  after insert on public.incident_reports
  for each row
  when (new.severity >= 4)
  execute function auto_blacklist_check();

-- 6. Index for Fast Blacklist Lookup
create index idx_blacklist_phone on public.guest_blacklist(phone);

